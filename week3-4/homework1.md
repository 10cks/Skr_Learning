# 第3-4周 Compiler

## 1. 进度

- 这周有很多的实验与小测，很赶，才写完parser
- 相关代码地址：[lexer](https://github.com/Kiprey/Skr_Learning/blob/master/week3-4/PA2/cool.flex) 
  | [parser](https://github.com/Kiprey/Skr_Learning/tree/master/week3-4/PA3/cool.y)

## 2. 思考题

### a. 思考题1

> 写出浮点数和无符号整数的文法

#### 无符号整数

```text
D -> 1|2|3|4|5|6|7|8|9
N -> (N|ε)(D|0)
I -> D(N|ε)
```

#### 浮点数

```text
D -> 1|2|3|4|5|6|7|8|9
N -> (N|ε)(D|0)
I -> D(N|ε)

F -> I.N
```

### b. 思考题2

> 描述每种文法（LL(1),SLR, LR(1), LALR等...)的使用条件，和它是为了解决什么问题？

- `LL(1)` :
  - 使用条件： 对于产生式A->α|β
    1. 当α、β均不能推出ε时，FIRST(α) ∩ FIRST(β) = φ
    2. α、β最多有一个能推出ε。同时当α、β中的某个符号推出ε时，另一个符号的FOLLOW集 ∩ FIRST(A) = φ
- `SLR` :
  - 使用条件：不产生冲突
  - 解决的问题：`LR(0)`没有考虑文法符号的上下文环境，当进入任何一个规约状态时，总是会采取规约动作，这会造成 __归约-移入冲突__。而`SLR`限制了规约条件，也就是当进入规约状态时，只有当下一个符号属于规约项目的FOLLOW集时，才可以进行规约动作。
- `LR(1)` :
  - 使用条件：需要忍受`LR(1)`自动机的高状态数所带来的影响。
  - 解决的问题： `SLR`只是简单判断下一个输入符号是否属于规约项目的FOLLOW集，只能排除不合理的规约而不能确保正确的规约。而`LR(1)`引入 __后继符__ 这个概念。后继符集合是FOLLOW集的子集，故可进一步限制了规约的条件。
- `LALR` :
  - 使用条件：合并项集后所构造出的语法分析表中，不存在语法分析动作冲突。
  - 解决的问题： `LR(1)`根据展望符集合的不同，将原始的`LR(0)`项目分裂成了不同的`LR(1)`项目。这会增大`LR(1)`自动机的状态数。而`LALR`将相同核心的`LR(1)`项集合并为一个项集，从而减少自动机的状态数。

### c. 思考题3
> 阅读用flex和bison生成出来的cool代码lexer和parser，理清代码骨架。  
> 此外，找一个真实软件中使用类似的工具生成的lexer和parser分析，如sqlite/mysql等。

粗略翻了一下，lexer和parser代码稍微有点复杂，那些神奇的变量名令人头大，还没开始研究Orz。


- lexer
  - `lextest.cc`中，main函数首先执行`handle_flags`函数，处理所传入参数并设置相关的`flag`
  - 之后打开源文件，循环执行`cool_yylex`函数与`dump_cool_token`函数。每次循环只读取一个token，并在`dump_cool_token`函数中输出。
  - `cool_yylex`函数位于`cool-lex.cc 1043h`文件中。该文件是flex动态生成的源文件。


这个......暂无